//=================================================================================
// Time.cpp
// Author: Tyler George
// Date  : January 27, 2015
//=================================================================================

#define WIN32_LEAN_AND_MEAN

////===========================================================================================
///===========================================================================================
// Includes
///===========================================================================================
////===========================================================================================
#include <Windows.h>
#include "Engine/Utilities/Time.hpp"
#include "Error.hpp"


////===========================================================================================
///===========================================================================================
// Global Variables
///===========================================================================================
////===========================================================================================
double g_secondsPerTick; 
LARGE_INTEGER g_ticksPerSecond;


////===========================================================================================
///===========================================================================================
// Time Utility Functions
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void InitializeTimeSystem()
{
    if (QueryPerformanceFrequency( &g_ticksPerSecond ));
    else
    {
        // problem
        __debugbreak();
    }
	g_secondsPerTick = 1.0 / g_ticksPerSecond.QuadPart;

    Clock::InitializeMasterClock();

}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
double GetCurrentSeconds()
{

	LARGE_INTEGER currentTicks;
	QueryPerformanceCounter( &currentTicks );

	double currentSeconds = currentTicks.QuadPart * g_secondsPerTick;

	return currentSeconds;
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
uint64_t TimeGetOpCount()
{
    LARGE_INTEGER opCount;
    
    if (QueryPerformanceCounter( &opCount ))
        return (uint64_t)opCount.QuadPart;
    else
        return 0;
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
long long TimeGet_ms()
{
    LARGE_INTEGER currentOpCount;
    if (QueryPerformanceCounter( &currentOpCount ))
        return (1000LL * currentOpCount.QuadPart) / g_ticksPerSecond.QuadPart;
    else
        return 0;
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
long long TimeGet_us()
{
    LARGE_INTEGER currentOpCount;
    if (QueryPerformanceCounter( &currentOpCount ))
        return (1000LL * 1000LL * currentOpCount.QuadPart) / g_ticksPerSecond.QuadPart;
    else
        return 0;
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
uint64_t TimeOpCountTo_us( uint64_t opCount )
{
    return ( 1000 * 1000 * opCount ) / g_ticksPerSecond.QuadPart;
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
float TimeOpCountTo_ms( uint64_t opCount )
{
    uint64_t timeMicroSec = TimeOpCountTo_us( opCount );
    return (float)( timeMicroSec ) / 1000.0f;
 }


////===========================================================================================
///===========================================================================================
// Clock class
///===========================================================================================
////===========================================================================================

////===========================================================================================
///===========================================================================================
// Static Variable Initialization
///===========================================================================================
////===========================================================================================

Clock* Clock::s_masterClock = nullptr;
unsigned int Clock::s_nextClockID = 1;

std::map< unsigned int, Timer* > Timer::s_allTimers;
unsigned int Timer::s_nextTimerID = 1;


////===========================================================================================
///===========================================================================================
//  Constructors/Destructors
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
Clock::Clock( Clock* parent, double maxDeltaSeconds )
    : m_parent( parent ? parent : s_masterClock )
    , m_clockID( s_nextClockID++ )
    , m_currentSeconds( 0 )
    , m_lastDeltaSeconds( 0.0 )
    , m_maxDeltaSeconds( maxDeltaSeconds )
    , m_timescale( 1.0f )
    , m_isPaused( false )
{
    m_parent->AddChild( this );
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
Clock::~Clock()
{
    if (m_parent)
    {
        // erase this entry from parent's children
        m_parent->m_children.erase( m_parent->m_children.find( m_clockID ) );
    }
//     else
//         RECOVERABLE_ASSERT( m_children.empty() );

    if (!m_children.empty())
    {
        // replace all children's parent with my parent
        for (ClockMap::iterator clockIter = m_children.begin(); clockIter != m_children.end(); ++clockIter)
        {
            Clock* child = clockIter->second;
            child->m_parent = m_parent;
        }
    }


    // Delete alarms
    for (AlarmMap::iterator alarmIter = m_alarms.begin(); alarmIter != m_alarms.end();)
    {
        Alarm* alarm = alarmIter->second;
        alarmIter = m_alarms.erase( alarmIter );

        delete alarm;
    }

}

////===========================================================================================
///===========================================================================================
// Initialization
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void Clock::InitializeMasterClock()
{
    if (!s_masterClock)
        s_masterClock = new Clock();
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void Clock::Shutdown()
{
    delete s_masterClock;
}

////===========================================================================================
///===========================================================================================
// Accessors/Queries
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
float Clock::GetAlarmPercentElapsed( const std::string& alarmName )
{
    AlarmMap::const_iterator alarmIter = m_alarms.find( alarmName );

    if (alarmIter == m_alarms.end())
        return -1.0f;

    Alarm* alarm = alarmIter->second;
    return (float)(alarm->m_currentElapsedSeconds / alarm->m_lengthSeconds);
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
float Clock::GetAlarmPercentRemaining( const std::string& alarmName )
{
    AlarmMap::const_iterator alarmIter = m_alarms.find( alarmName );

    if (alarmIter == m_alarms.end())
        return -1.0f;

    Alarm* alarm = alarmIter->second;
    return 1.0f - (float)(alarm->m_currentElapsedSeconds / alarm->m_lengthSeconds);
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
double Clock::GetAlarmSecondsRemaining( const std::string& alarmName )
{
    AlarmMap::const_iterator alarmIter = m_alarms.find( alarmName );

    if (alarmIter == m_alarms.end())
        return -1.0;

    Alarm* alarm = alarmIter->second;
    return alarm->m_lengthSeconds - alarm->m_currentElapsedSeconds;
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
double Clock::GetAlarmSecondsElapsed( const std::string& alarmName )
{
    AlarmMap::const_iterator alarmIter = m_alarms.find( alarmName );

    if (alarmIter == m_alarms.end())
        return -1.0;

    Alarm* alarm = alarmIter->second;
    return alarm->m_currentElapsedSeconds;
}



////===========================================================================================
///===========================================================================================
// Mutators
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void Clock::AddChild( Clock* child )
{
    m_children.insert( std::pair< unsigned int, Clock* >( child->m_clockID, child ) );
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void Clock::SetAlarm( const std::string& alarmName, double lengthSeconds, AlarmCallback* cb, void* const data )
{
    Alarm* newAlarm = new Alarm( alarmName, lengthSeconds, cb, data );
    m_alarms.insert( std::pair< std::string, Alarm* >( alarmName, newAlarm ) );
}

////===========================================================================================
///===========================================================================================
// Update
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void Clock::Update( double deltaseconds )
{
    s_masterClock->AdvanceTime( deltaseconds );
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void Clock::AdvanceTime( double deltaseconds )
{
    if (m_maxDeltaSeconds > 0.0 && deltaseconds > m_maxDeltaSeconds)
        deltaseconds = m_maxDeltaSeconds;

    deltaseconds *= (double) m_timescale;

    if (m_isPaused)
        deltaseconds = 0.0;

    m_lastDeltaSeconds = deltaseconds;
    m_currentSeconds += deltaseconds;

    for (ClockMap::iterator clockIter = m_children.begin(); clockIter != m_children.end(); ++clockIter)
    {
        Clock* child = clockIter->second;

        child->AdvanceTime( deltaseconds );
    }

    UpdateAlarms();
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void Clock::UpdateAlarms()
{
    for (AlarmMap::iterator alarmIter = m_alarms.begin(); alarmIter != m_alarms.end(); )
    {
        Alarm* alarm = alarmIter->second;
        
        alarm->m_currentElapsedSeconds += m_lastDeltaSeconds;
        
        // alarm finished
        if (alarm->m_currentElapsedSeconds >= alarm->m_lengthSeconds)
        {
            AlarmCallback* cb = alarm->m_callbackFunc;
            (*cb)(alarm->m_data);
            delete alarm;

            alarmIter = m_alarms.erase( alarmIter );
            continue;
        }

        ++alarmIter;
    }
}

////===========================================================================================
///===========================================================================================
// Private Functions
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
Clock::Clock()
    : m_parent( nullptr )
    , m_clockID( s_nextClockID++ )
    , m_currentSeconds( 0.0 )
    , m_lastDeltaSeconds( 0.0 )
    , m_maxDeltaSeconds( -1.0 )
    , m_timescale( 1.0f )
    , m_isPaused( false )
{

}

////===========================================================================================
///===========================================================================================
// Timer class
///===========================================================================================
////===========================================================================================

////===========================================================================================
///===========================================================================================
// Constructors/Destructors
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
Timer::Timer( Clock* referenceClock )
    : m_referenceClock( referenceClock ? referenceClock : Clock::GetMasterClock() )
    , m_elapsedTime( 0.0 )
    , m_timerID( s_nextTimerID++ )
{
    s_allTimers.insert( std::pair< unsigned int, Timer* >( m_timerID, this ) );
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
Timer::~Timer()
{
    s_allTimers.erase( s_allTimers.find( m_timerID ) );
}

////===========================================================================================
///===========================================================================================
// Accessors
///===========================================================================================
////===========================================================================================

////===========================================================================================
///===========================================================================================
// Update
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void Timer::UpdateAllTimers()
{
    for (std::map< unsigned int, Timer* >::iterator timerIter = s_allTimers.begin(); timerIter != s_allTimers.end(); ++timerIter)
    {
        Timer* timer = timerIter->second;
        timer->Update();
    }
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void Timer::Update()
{
    m_elapsedTime += m_referenceClock->GetLastDeltaSeconds();
}
