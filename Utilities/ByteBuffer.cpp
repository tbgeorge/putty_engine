//=================================================================================
// ByteBuffer.cpp
// Author: Tyler George
// Date  : January 27, 2016
//=================================================================================

////===========================================================================================
///===========================================================================================
// Includes
///===========================================================================================
////===========================================================================================
#include "Engine/Utilities/ByteBuffer.hpp"
#include <memory.h>

////===========================================================================================
///===========================================================================================
// ByteBuffer class
///===========================================================================================
////===========================================================================================

////===========================================================================================
///===========================================================================================
//  Initialization
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void ByteBuffer::Startup( void* buffer, size_t maxSize )
{
    m_readIndex = 0;
    m_writeIndex = 0;

    m_maxSize = maxSize;
    m_buf = (unsigned char*) buffer;
        
}

////===========================================================================================
///===========================================================================================
// Accessors
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
size_t ByteBuffer::GetLength()
{
    return m_writeIndex;
}

///---------------------------------------------------------------------------------
/// Reads from buffer, copying data up to size into data
/// @return
///      number of bytes read, should equal size on success
///      if less than size, there was not enough data.
///      Advanced read index either way
///---------------------------------------------------------------------------------
size_t ByteBuffer::ReadBytes( void* out_data, size_t size )
{
    unsigned char* readStart = m_buf + m_readIndex;

    size_t remainingData = m_maxSize - m_readIndex;

    size_t amtToRead = 0;
    if (size <= remainingData)
        amtToRead = size;
    else
        amtToRead = remainingData;

    memcpy( out_data, readStart, amtToRead );

    m_readIndex += amtToRead;

    return amtToRead;
}

////===========================================================================================
///===========================================================================================
// Mutators
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void ByteBuffer::SetLength( size_t len )
{
    m_writeIndex = len;
}

///---------------------------------------------------------------------------------
/// When you write, you write to the end of the buffer
/// @return
///     true: was enough room and was written
///      false: not enough room and was not written
///---------------------------------------------------------------------------------
bool ByteBuffer::WriteBytes( void* data, size_t size )
{
    size_t spaceRemaining = m_maxSize - m_writeIndex;

    // can write
    if (size <= spaceRemaining)
    {
        unsigned char* writeStart = m_buf + m_writeIndex;
        memcpy( writeStart, data, size );

        m_writeIndex += size;
        return true;
    }

    // can't write
    else
        return false;
}